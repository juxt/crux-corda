= Crux Corda
:toc:
:toc-placement: preamble
:toclevels: 2


A library that allows you to pipe verified https://docs.corda.net/docs/corda-os/4.8/api-transactions.html[Corda transactions] into a https://opencrux.com[Crux] node, to then query using Crux's bitemporal Datalog query engine.We recommend you read our https://juxt.pro/blog/on-bridging-databases-and-blockchain[featured blog post "On bridging blockchain and databases"] to learn more about the background for this library.

== Corda 101

https://www.corda.net/[Corda] is a blockchain development platform. It embraces a permissioned distributed ledger model based on Public Key Infrastructure.

It is primarily written in https://kotlinlang.org/[Kotlin], a member of the JVM family of languages.

https://docs.corda.net/docs/corda-os/4.8/cordapp-overview.html[CordDApps] (Corda Distributed Applications) are distributed applications that run on the Corda platform. The goal of a CorDapp is to allow nodes to reach agreement on updates to the ledger. They achieve this goal by defining flows that Corda node owners can invoke over RPC.

== Requirements

If you already run a CorDApp and are looking to integrate Crux as a new feature, feel free to skip this section.

If you are new to Corda, we recommend going through the following material:

. https://docs.corda.net/docs/corda-os/4.8/key-concepts.html[Key Concepts]. In particular *States*, *Flows*, and *Transactions*
. Going over the https://docs.corda.net/docs/corda-os/4.7/hello-world-introduction.html[Hello World tutorial]
. https://docs.corda.net/docs/corda-os/4.8/node-services.html[The Service Hub], not essential but a good troubleshooting reference

== Preparing your CorDApp to use `crux-corda`

Flows can't query Crux out of the box. In order to integrate `crux-corda`

. States must implement the `CruxState` interface so they can be consumed by `crux-corda` and piped into Crux.
. Register Crux with Corda's ServiceHub
. Optionally, we can filter which states get piped in

image::https://juxt-resources.netlify.app/img/crux-corda-diag.png["Flow diagram",width=700]

We will use the *IOU CorDApp* to further illustrate the setup.

=== Getting Started

WARNING: This project is still in an experimental phase. It has not been uploaded to Maven.

WARNING: `crux-corda` is currently compatible with `crux` no __later__ than version https://github.com/juxt/crux/releases/tag/21.01-1.14.0[`21.01-1.14.0-beta`]

NOTE: This section assumes you are on a Corda Project, eg. `IOU CorDApp` from the https://docs.corda.net/docs/corda-os/4.7/hello-world-introduction.html[Hello World tutorial], and using Gradle as a build tool.

Start by cloning this repo. Locate the `crux-corda` and `crux-corda-state` directories within. Copy them into your project root, and let Gradle know about them in `settings.gradle.kts`.

[source,kotlin]
----
// ...
include("crux-corda-state", "crux-corda", ....)
----

This way you can later reference them as project dependencies in a `build.gradle.kts`. Don't forget to include `crux` as well.

[source,kotlin]
----
dependencies{
    // ...
    implementation("juxt", "crux-core", "20.09-1.12.1-beta")
    cordapp(project(":crux-corda-state"))
    cordapp(project(":crux-corda"))
    // ...
}

----

=== Implement the CruxState interface

States in Corda have a schema and live in memory as Objects. Crux in contrast deals with schemaless EAV triples.

In order for `crux-corda` to consume a Corda state it must first implement `CruxState`

.link:/iou-contract/src/main/kotlin/com/example/contract/IOUState.kt[] - example of a Corda state with a Crux mapping
[source,kotlin]
----
@BelongsToContract(IOUContract::class)
data class IOUState(val value: Int,
                    val lender: Party,
                    val borrower: Party,
                    override val linearId: UniqueIdentifier = UniqueIdentifier()) :
    LinearState, CruxState {

    override val cruxId = linearId.id
    override val cruxDoc: Map<String, Any> = mapOf(
        "iou-state/value" to value,
        "iou-state/lender" to lender.name.toString(),
        "iou-state/borrower" to borrower.name.toString())
}
----

=== Configure and Run Crux in the Service Hub

.In order to run Crux, register a new node like so
[source,kotlin]
----
@CordaService
class CruxService(private val serviceHub: AppServiceHub) : SingletonSerializableAsToken() {
    val node = serviceHub.startCruxNode {
        // configure node
    }
}
----

By default, https://opencrux.com/reference/20.09-1.12.1/configuration.html[the Crux API] starts an in-memory node.

WARNING: The only constraint to Crux's node configuration in this case is *you must use the custom Corda Tx Log*. By importing `crux-corda` as a dependency, the Crux API is automatically extended with the Corda Tx Log, as well as setting it up as default

.Here is how to configure its behaviour. By default, any validated CruxState is piped into Crux.
[source,kotlin]
----
val node = serviceHub.startCruxNode {
    withCordaTxLog {
        withDocumentMapping { doc ->
            // this is the default implementation,
            // replace it with your own mapping
            if (doc is CruxState) listOf(doc)
            else null
        }
    }
}
----

== Querying Crux

Since we are running a real Crux node, we can refer to the https://opencrux.com/reference/20.09-1.12.1/queries.html[Queries API] directly once we grab onto a Crux node reference.


[source,kotlin]
----
val cruxNode = serviceHub.cordaService(CruxService::class.java)

cruxNode.db().query("""
    {:find [?l ?b ?v]
     :where [[?iou :iou-state/lender ?l]
             [?iou :iou-state/borrower ?b]
             [?iou :iou-state/value ?v]]}
    """.trimIndent())
----

TIP: Keep in mind the Crux database is not global, but local to each Corda node. You can't query facts that have happened in other nodes unless explicitly shared with yours through a Corda Flow.

== Examples

This repo contains a more elaborate example app that builds on top of the https://docs.corda.net/docs/corda-os/4.7/hello-world-introduction.html[Hello World tutorial].

We will limit ourselves to running our app inside tests by Mocking the network, as well as the Corda nodes. Should you want to run real nodes, follow the https://docs.corda.net/docs/corda-os/4.8/run-your-cordapp.html[tutorial on the subject].

Make sure you can run the `crux-corda:iou-workflow` tests either from your IDE or from the command line with `./gradlew -p iou-workflow test` from the project root.

There's a total of 3 tests in `com.example.workflow.IOUFlowTests`.

=== `flow records the correct IOU in both parties' vaults`
We create an `IOUState` between nodes A and B. Since `IOUState` has been modified to implement `CruxState` in addition to `LinearState`, the `CordaService` on each node has picked up the transaction.

.We can verify this by issuing a Crux Query
[source,kotlin]
----
            assertEquals(
                listOf(a.info.singleIdentity().name.toString(), b.info.singleIdentity().name.toString(), 1L),
                cruxNode.db().query("""
                    {:find [?l ?b ?v]
                     :where [[?iou :iou-state/lender ?l]
                             [?iou :iou-state/borrower ?b]
                             [?iou :iou-state/value ?v]]}""".trimIndent())
                    .first()
            )
----

.We can also verify that, at different points in time, the query returns the same result for a database value in the future, and no results for a database value in the past
[source,kotlin]
----
            // Crux knows about the transaction three days from now
            assertEquals(
                listOf(a.info.singleIdentity().name.toString(), b.info.singleIdentity().name.toString(), 1L),
                cruxNode.db(inThreeDays).query("""
                    {:find [?l ?b ?v]
                     :where [[?iou :iou-state/lender ?l]
                             [?iou :iou-state/borrower ?b]
                             [?iou :iou-state/value ?v]]}""".trimIndent()).first()
            )
            // Crux does not know about the transaction three days ago
            assertEquals(
                emptySet(),
                cruxNode.db(threeDaysAgo).query("""
                    {:find [?l ?b ?v]
                     :where [[?iou :iou-state/lender ?l]
                             [?iou :iou-state/borrower ?b]
                             [?iou :iou-state/value ?v]]}"""
                        .trimIndent())
            )
----

=== `A lends money to B, B buys a "house"`

We introduce a new State class - `com.example.contract.ItemState`. An item has a name, a value, and an owner. The owner of the item - a Corda Node - is the only party aware of the state.
`com.example.workflow.ItemFlow` defines how to create a new `ItemState`. The catch is in order to do so, the Party needs a positive balance.

.The balance depends on the money lent, borrowed, as well as other items' value. It is calculated as follows:
----
balance = money_borrowed - money_lent - owned_items_value
----

.We can calculate these values with a Crux query each.
[source,kotlin]
----
val money_borrowed = currentDb.query("""
        {:find [(sum ?v)]
         :in [?b]
         :where [[?iou :iou-state/borrower ?b]
                 [?iou :iou-state/value ?v]]}
""".trimIndent(), me.name.toString()).singleOrNull()?.singleOrNull() as Long? ?: 0
val money_lent = currentDb.query("""
        {:find [(sum ?v)]
         :in [?l]
         :where [[?iou :iou-state/lender ?l]
                 [?iou :iou-state/value ?v]]}
""".trimIndent(), me.name.toString()).singleOrNull()?.singleOrNull() as Long? ?: 0
val owned_items_value = currentDb.query("""
        {:find [(sum ?v)]
         :in [?o]
         :where [[?item :item/owner ?o]
                 [?item :item/value ?v]]}
""".trimIndent(), me.name.toString()).singleOrNull()?.singleOrNull() as Long? ?: 0
----

If we try to initiate an `ItemFlow` with a balance lesser than the value of the item, the flow throws an exception.

As the test describes, we start by lending B enough money to buy an item. B can then start an `ItemFlow` to create an `ItemState`.

.The query that follows exemplifies how, starting with a particular lender, we can retrieve all items that have been acquired by its borrowers, effectively turning 2 Corda vault queries into 1.
[source,kotlin]
----
assertEquals(
        listOf("house", 3L),
        newDb.query("""
            {:find [?name ?value]
             :in [?lender]
             :where [[?iou :iou-state/borrower ?borrower]
                     [?iou :iou-state/lender ?lender]
                     [?item :item/owner ?borrower]
                     [?item :item/name ?name]
                     [?item :item/value ?value]]}
    """.trimIndent(), a.info.singleIdentity().name.toString()).single())
----

=== `A lends 10 to B, then B lends 20 to A, resulting in A owing 10`

We modified `com.example.workflow.IOUFlow` and `com.example.contract.IOUContract` by allowing not only the creation of an `IOUState`, but its update. The updated flow dictate there can only be one active IOU statement between the same 2 parties. When a new `IOUFlow` is started by a node, we first fetch any existing `UNCONSUMED` `IOUState` between both parties.

If none such state exists, we proceed as previously by creating a new state. In case there already exists one, we use it as an input to the new `Commands.UpdateIOU` in `IOUContract`. The new `IOUState.value` is calculated based on who is lending / borrowing, as well as the role of each party.

At the end of the test, two Crux queries help us verify that

. After the update, the roles have been reversed
+
[source,kotlin]
----
// After the first transaction, B owes A money
assertEquals(
        listOf(10L, aId.toString(), bId.toString()),
        firstDB.query("""
            {:find [?v ?l ?b]
             :where [[?iou :iou-state/borrower ?b]
                     [?iou :iou-state/lender ?l]
                     [?iou :iou-state/value ?v]]}
        """.trimIndent()).single())

// After the second transaction, A owes B money
assertEquals(
        listOf(10L, bId.toString(), aId.toString()),
        secondDB.query("""
            {:find [?v ?l ?b]
             :where [[?iou :iou-state/borrower ?b]
                     [?iou :iou-state/lender ?l]
                     [?iou :iou-state/value ?v]]}
        """.trimIndent()).single())
----
. Both versions of the database see the same entity updated, same as Corda does
+
[source,kotlin]
----
// It is the same CRUX fact too
assertEquals(
        firstDB.query("""
            {:find [?id]
             :in [?l]
             :where [[?iou :crux.db/id ?id]
                     [?iou :iou-state/lender ?l]]}
        """.trimIndent(), aId.toString()),
        secondDB.query("""
            {:find [?id]
             :in [?b]
             :where [[?iou :crux.db/id ?id]
                     [?iou :iou-state/borrower ?b]]}
        """.trimIndent(), aId.toString())
----

== Limitations
== Contributing

